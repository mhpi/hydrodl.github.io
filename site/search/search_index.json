{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"HydroDL","text":"<p>Landing page coming soon...</p>"},{"location":"#benchmarks","title":"Benchmarks","text":""},{"location":"Contribute/","title":"Contribute","text":""},{"location":"Contribute/#tbd","title":"TBD","text":""},{"location":"Example/","title":"Examples","text":"<p>Several examples related to the above papers are presented here. Click the title link to see each example.</p>"},{"location":"Example/#1train-a-lstm-data-integration-model-to-make-streamflow-forecast","title":"1.Train a LSTM data integration model to make streamflow forecast","text":"<p>The dataset used is NCAR CAMELS dataset. Download CAMELS following this link.  Please download both forcing, observation data <code>CAMELS time series meteorology, observed flow, meta data (.zip)</code> and basin attributes <code>CAMELS Attributes (.zip)</code>.  Put two unzipped folders under the same directory, like <code>your/path/to/Camels/basin_timeseries_v1p2_metForcing_obsFlow</code>, and <code>your/path/to/Camels/camels_attributes_v2.0</code>. Set the directory path <code>your/path/to/Camels</code> as the variable <code>rootDatabase</code> inside the code later.</p> <p>Computational benchmark: training of CAMELS data (w/ or w/o data integration) with 671 basins, 10 years, 300 epochs, in ~1 hour with GPU.</p>"},{"location":"Installation/","title":"Installation","text":""},{"location":"Installation/#installation","title":"Installation","text":"<p>There are two different methods for hydroDL installation:</p>"},{"location":"Installation/#create-a-new-environment-then-activate-it","title":"Create a new environment, then activate it","text":"<pre><code>conda create -n mhpihydrodl python=3.7\nconda activate mhpihydrodl\n</code></pre>"},{"location":"Installation/#using-pypi-stable-package","title":"Using PyPI (stable package)","text":"<p>Install our hydroDL stable package from pip (Python version&gt;=3.0)</p> <pre><code>pip install hydroDL\n</code></pre>"},{"location":"Installation/#source-latest-version","title":"Source latest version","text":"<p>Install our latest hydroDL package from github</p> <pre><code>git clone https://github.com/mhpi/hydroDL.git\n</code></pre> <p>Note: If you want to run our examples directly, please download the example folder (It contains the code and data for these examples). </p> <p>There exists a small compatibility issue with our code when using the latest pyTorch version. Feel free to contact us if you find any issues or code bugs that you cannot resolve.</p>"},{"location":"Quick_start/","title":"Quick Start:","text":"<p>The detailed code for quick start can be found in tutorial_quick_start.py</p> <p>See below for a brief explanation of the major components you need to run a hydroDL model:</p> <pre><code># imports\nfrom hydroDL.model.crit import RmseLoss\nfrom hydroDL.model.rnn import CudnnLstmModel as LSTM\nfrom hydroDL.model.train import trainModel\nfrom hydroDL.model.test import testModel\n\n# load your training and testing data \n# x: forcing data (pixels, time, features)\n# c: attribute data (pixels, features)\n# y: observed values (pixels, time, 1)\nx_train, c_train, y_train, x_val, c_val, y_val = load_data(...)\n\n# define your model and loss function\nmodel = LSTM(nx=num_variables, ny=1)\nloss_fn = RmseLoss()\n\n# train your model\nmodel = trainModel(model,\n    x_train,\n    y_train,\n    c_train,\n    loss_fn,\n)\n\n# validate your model\npred = testModel(model,\n             x_val,\n             c_val,\n)\n</code></pre>"},{"location":"blog/","title":"Blog","text":""},{"location":"docs/","title":"Docs","text":"<p>HydroDL's differentiable modeling interface is set up to provide a seemless template for using physics models and neural networks together. </p> <p>Our framework provides a standard for differentiable physics models to follow such that anyone can plug their models together. </p>"},{"location":"docs/#sections","title":"Sections","text":"<ul> <li>Datasets</li> <li>Neural Networks</li> <li>Physics Models</li> <li>Experiments</li> <li>Configs</li> </ul>"},{"location":"docs/#plugins","title":"Plugins","text":"<p>Plugins are a way to build off of open-source Deep Learning papers and repositories. </p>"},{"location":"docs/datasets/","title":"Datasets","text":"<p>The Datasets used in hydroDL are individual <code>@dataclass</code> classes used to create a Pytorch <code>torch.utils.data.Dataloader</code>. The classe</p> <code>Data</code> <p>Inputs to the neural networks</p> <code>Observations</code> <p>Targets used when training</p>"},{"location":"docs/datasets/#data","title":"Data","text":"<p>Data classes are implementations of the following <code>ABC</code> class:</p> __init__.Data.py<pre><code>from abc import ABC, abstractmethod\n\nfrom omegaconf import DictConfig\nimport torch\n\nclass Data(ABC):\n     @abstractmethod\n    def __init__(self, cfg: DictConfig, dates: Dates, normalize: Normalize):\n        \"\"\"A function to define what inputs are required by a Data object\"\"\"\n        pass\n\n    @abstractmethod\n    def _read_attributes(self) -&gt; None:\n        \"\"\"\n        Abstract method for reading attributes related to the data.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _read_forcings(self) -&gt; None:\n        \"\"\"\n        Abstract method for reading attributes related to the data.\n        :return: None\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _read_data(self) -&gt; None:\n        \"\"\"The method to read all data\"\"\"\n        pass\n\n    @abstractmethod\n    def get_data(self) -&gt; Hydrofabric:\n        \"\"\"\n        Abstract method for retrieving data in the form of a hydrofabric\n\n        \"\"\"\n        pass\n</code></pre>"},{"location":"docs/experiments/","title":"Experiments","text":"<p>HydroDL experiments are designed to seamlessly be both reusableand structured. All experiments are child classes of the base <code>Experiment</code> class:</p> __init__.Experiment.py<pre><code>from abc import ABC, abstractmethod\nfrom typing import Dict, Type\n\nimport torch\nimport torch.nn\n\nclass Experiment(ABC):\n    @abstractmethod\n    def run(\n        self,\n        data_loader: torch.utils.data.DataLoader,\n        neural_network: nn.Module,\n        physics_models: Dict[str, Type[nn.Module]],\n    ) -&gt; None:\n        \"\"\"a method that runs your experiment\"\"\"\n        pass\n</code></pre> <p>The arguments passed into the parameters of the run function are all either class references (<code>physics_models</code>) or full instantiated classes (<code>data_loader</code>, or <code>neural_network</code>)</p>"},{"location":"docs/neural_networks/","title":"Neural Networks","text":"<p>Neural Networks are configured similar to how they are instantiated in other PyTorch packages. </p> <pre><code>from functools import partial\n\nfrom omegaconf import DictConfig\nimport torch\nimport torch.nn as nn\n\nfrom hydroRoute.neural_networks import Initialization\n\nclass NN(nn.Module):\n    def __init__(self, cfg: DictConfig):\n        super(MLP, self).__init__()\n        self.cfg = cfg\n        self.Initialization = Initialization(self.cfg)\n\n    def initialize_weights(self) -&gt; None:\n        \"\"\"\n        The partial function used to \n        \"\"\"\n        func = self.Initialization.get()\n        init_func = partial(self._initialize_weights, func=func)\n        self.apply(init_func)\n\n    @staticmethod\n    def _initialize_weights(m, func) -&gt; None:\n        \"\"\"\n        An internal class used to intialize weights based\n        on a provided initialization function\n        \"\"\"\n        if isinstance(m, nn.Linear):\n            func(m.weight)\n\n    def forward(self, inputs: torch.Tensor) -&gt; None:\n        pass\n</code></pre>"},{"location":"docs/physics_models/","title":"Physics Models","text":"<p>HydroDL's implemented physics models are all child classes of the Pytorch <code>nn.Module</code> class. By creating your physics model as an nn.Module, you can tap into PyTorch's neural network functionality and get a lot of bonuses. </p>"},{"location":"docs/physics_models/#basics","title":"Basics","text":"<p>Our physics models are structured as follows:</p> <pre><code>from typing import Tuple\n\nimport torch\nimport torch.nn as nn\n\nclass PhysicsModel(nn.Module):\n    def __init__(self, cfg: DictConfig) -&gt; None:\n        super(PhysicsModel, self).__init__()\n        self.cfg = cfg\n\n    def forward(self, inputs: Tuple[..., torch.Tensor]) -&gt; torch.Tensor:\n</code></pre> <p>Where all that is required by a physics model is it's specified configuration file. Since there are different requirements for each physics model, it is necessary for you to read into the specific configurations required by each module. </p>"},{"location":"docs/plugins/","title":"Plugins","text":""},{"location":"docs/plugins/hydrodl/","title":"HydroDL","text":""},{"location":"projects/","title":"Projects","text":"<p>See below for our projects</p> <ul> <li> <p>\\(\\delta\\) HBV-globe1.0-hydroDL (Feng et al. 2023)</p> <p>A differentiable implementation of the HBV Streamflow Model.</p> <p> Read More Here</p> </li> </ul> <ul> <li> <p>\\(\\delta\\) MC-Juniata-hydroDL2 (Bindas et al. 2023)</p> <p>A differentiable routing method that mimics the classical Muskingum-Cunge routing model over a river network but embeds an NN to infer parameterizations for Manning\u2019s roughness (n) and channel geometries from raw reach-scale attributes like catchment areas and sinuosity. </p> <p> Read More Here</p> </li> </ul>"},{"location":"projects/bindas_2023/","title":"\\(\\delta\\) MC-Juniata-hydroDL2","text":"<p>Info</p> <p>This paper is currently in preprint</p>"},{"location":"projects/bindas_2023/#code-release","title":"Code Release","text":"<p>Will be released upon publication</p>"},{"location":"projects/bindas_2023/#results","title":"Results","text":"<p>Will be released upon publication</p>"},{"location":"projects/bindas_2023/#bibtex-citation","title":"Bibtex Citation","text":"<pre><code>@techreport{bindas2023improving,\n  title={Improving large-basin streamflow simulation using a modular, differentiable, learnable graph model for routing},\n  author={Bindas, Tadd and Tsai, Wen-Ping and Liu, Jiangtao and Rahmani, Farshid and Feng, Dapeng and Bian, Yuchen and Lawson, Kathryn and Shen, Chaopeng},\n  year={2023},\n  institution={Copernicus Meetings}\n}\n</code></pre>"},{"location":"projects/feng_2023/","title":"\\(\\delta\\) HBV-globe1.0-hydroDL","text":"<p>Documentation coming soon</p>"},{"location":"projects/feng_2023/#bibtex-citation","title":"Bibtex Citation","text":"<pre><code>@article{feng2023deep,\n  title={Deep Dive into Global Hydrologic Simulations: Harnessing the Power of Deep Learning and Physics-informed Differentiable Models ($\\delta$HBV-globe1. 0-hydroDL)},\n  author={Feng, Dapeng and Beck, Hylke and de Bruijn, Jens and Sahu, Reetik Kumar and Satoh, Yusuke and Wada, Yoshihide and Liu, Jiangtao and Pan, Ming and Lawson, Kathryn and Shen, Chaopeng},\n  journal={Geoscientific Model Development Discussions},\n  volume={2023},\n  pages={1--23},\n  year={2023},\n  publisher={G{\\\"o}ttingen, Germany}\n}\n</code></pre>"}]}